# 開発アプローチの比較：アジャイル vs ウォーターフォール

> 💡 開発に関する用語の説明は[用語集](terms_glossary.md)を参照してください。

## 開発手法の基本的な違い

| 項目 | ウォーターフォール型 | アジャイル型 |
|------|---------------------|-------------|
| 開発の進め方 | 工程を順番に進める | 短いサイクルで繰り返し開発 |
| 要件の確定タイミング | 開発開始前に全て確定 | 開発中も柔軟に変更可能 |
| 成果物の出し方 | 最後に一括で完成品を提供 | 少しずつ機能を追加・改善 |
| 変更への対応 | 変更が困難（手戻りが大きい） | 変更に柔軟に対応可能 |
| 品質管理の方法 | 工程ごとの承認と検証 | 継続的な確認と改善 |

## 1. ウォーターフォール型におけるドキュメントの完成条件

ウォーターフォール型では、以下の工程を順番に進めます：

1. 要件定義
2. 基本設計
3. 詳細設計
4. 実装
5. テスト
6. 運用

各工程で作成される文書は、次の工程に進む前に必ずステークホルダーの承認を得る必要があります。

### 1.1 要件定義書の完成条件

#### 含まれる情報
- 背景・目的・ゴール（何を実現するのか）
- 機能要件一覧（機能一覧表やユースケース）
- 非機能要件（性能・可用性・セキュリティ・拡張性など）
- 対象範囲・スコープ、優先度
- 制約事項・リスク・前提条件
- 受け入れ基準（最終的に満たすべき基準）

#### フォーマット
- WordやExcelでの要件定義書、PowerPointでの要件説明資料など
- 顧客/ビジネスサイドとエンジニアリング側双方が合意しやすいドキュメント形式

#### 完成条件（例）
- 機能要件と非機能要件が明確に定義されている
  - 抜け漏れがない、あいまいな表現がない
- スコープ・優先度について開発側と顧客側（発注元）が合意している
- リスクや制約が洗い出され、対応方針が検討されている
- 顧客・PM・主要ステークホルダーの承認（サインオフ）が得られている

**ポイント**: ウォーターフォールでは「要件定義書が承認された = 次の基本設計工程へ進む許可が下りた」という扱いになります。

### 1.2 基本設計書の完成条件

#### 含まれる情報
- システム構成図・アーキテクチャ（ハードウェア/ネットワーク/ソフトウェア構成）
- 外部インターフェース設計（連携先システム、API仕様 など）
- データベース概念設計（テーブル一覧、ER図）
- 画面の概要設計（画面遷移図、UIイメージ）
- 主要な処理フロー（機能ブロック単位のフローチャートなど）

#### フォーマット
- Word等の「基本設計書」テンプレートや、UMLツールの出力資料など
- 画面構成やUML（ユースケース図・クラス図・シーケンス図など）を文書に盛り込む

#### 完成条件（例）
- システムの全体構成・外部連携が明確になっている
  - インフラ、ネットワーク、外部サービス連携方法など
- 主要な業務フロー・処理フローの概要設計が固まっている
- データベースの概念設計・主テーブルの定義がある程度完了している
- 顧客・上流工程担当者・PM/リードエンジニアのレビューと承認が完了している

**ポイント**: 基本設計書により、システムの大まかな動きや構造が固まったとみなされ、次の「詳細設計」工程へ移れます。

### 1.3 詳細設計書の完成条件

#### 含まれる情報
- 画面定義書（各画面の項目・UI配置・遷移先など）
- テーブル定義書（カラム詳細、データ型、インデックス、制約条件など）
- クラス設計書・API仕様書（メソッド、引数、戻り値、エラー処理など）
- 処理フローチャート（機能単位の詳しいアルゴリズムや分岐条件）
- 非機能要件（セキュリティ、ログ出力、監視方法など）の具体的な実装方針

#### フォーマット
- Word/Excelの詳細設計テンプレート
- UMLツール出力のクラス図やシーケンス図
- 画面設計書（ワイヤーフレームなど）を組み込むことも

#### 完成条件（例）
- 開発者が迷わずコーディングできるレベルで仕様が詳細に定義されている
- テストケースを作成できるレベルまで情報が具体化されている
- 設計書のレビュー・承認（PM/アーキテクト/リードエンジニアなど）が完了している
- 要件定義書や基本設計書とのトレーサビリティが確保できている（どの要件をどの設計で実現しているか明確）

**ポイント**: 詳細設計書が承認されると、テスト仕様書の作成や実装工程に着手できます。ウォーターフォールではここの文書化が非常に重視されます。

## 2. アジャイル型におけるドキュメントの完成条件

アジャイル型では、ドキュメントを一度で「完成」とみなすよりは、必要なときに必要な粒度で更新し続ける運用が一般的です。ただし、それでも「最低限、どの程度まで書かれていれば"完了"と言えるか」を明文化しておくことが重要となります。これを「Definition of Done（DoD）」や「Definition of Ready（DoR）」などで設定するケースが多いです。

### 2.1 要件定義（ユーザーストーリー）の完成条件

ウォーターフォールでの「要件定義書」に相当する情報は、アジャイルでは主にプロダクトバックログやユーザーストーリーとして管理されます。

#### 含まれる情報
- ユーザーストーリー（誰が・何を・なぜやりたいのか）
- 受け入れ基準（Acceptance Criteria）
- 非機能要件や技術的制約（別途リスト化し、ストーリーやタスク化している場合も）
- ざっくりしたスコープと優先度

#### フォーマット
- JiraやTrelloなどのチケットツール
- GitHub Issues / Projectsで管理することも多い
- ユーザーストーリーをMarkdownで簡潔に記載（例：「As a (role), I want (feature), so that (benefit).」）

#### 完成条件（例: Definition of Ready / Done）
- ユーザーストーリーが明確
  - 「誰が（Persona）」「何を」「なぜ」が明確に書かれ、あいまいさがない
- 受け入れ基準が定義されている
  - ストーリーが「完了」したと判断するための条件が具体的
- 開発チームがストーリーを実装可能なレベルで内容を理解している
  - 疑問点が解決され、十分にディスカッションされた
- 見積もり（ポイント付け）と優先度付けが行われている
  - スプリント計画に組み込める状態

**ポイント**: ウォーターフォールのように「要件定義書を最終確定してサインオフ」という形よりも、常にバックログが更新されるのがアジャイル流です。

### 2.2 基本設計（アーキテクチャ設計）の完成条件

アジャイルでも最初から全く設計をしないわけではなく、アーキテクチャの骨格は早期に決めてチームで共有します。ただし、完成というよりは「現時点でのベスト」を都度更新するイメージです。

#### 含まれる情報
- システム構成図（フロントエンド／バックエンド／外部連携／AIなど）
- データフローやざっくりしたER図
- 主要な技術スタックと理由、インフラ構成（AWS, GCP など）
- 外部インターフェースの大まかな仕様

#### フォーマット
- GitHubリポジトリ内の /docs フォルダなどにMarkdownでまとめる
- Wiki/Confluenceを使う
- ADR（Architecture Decision Record）を作り、設計判断の経緯を記録

#### 完成条件（例: Definition of Done / ADR Done）
- アーキテクチャの方針がチーム内で合意されている
  - 主要技術・インフラ選定に異論がない
- 外部システム連携やDBなどの大枠が定義され、実装可能レベルの見通しがある
- 必要に応じて更新しやすい形（Git管理など）でドキュメント化されている
- レビュー済みで差分が承認されている（Pull Requestベースなど）

**ポイント**: アジャイルでは「基本設計書が全て完成してロックされる」というよりは、「変更があれば柔軟にアップデート」するため、完成条件＝現時点で開発に必要な情報が満たされ、合意されている状態を指すことが多いです。

### 2.3 詳細設計の完成条件

アジャイルの場合、詳細設計はスプリントごと・ユーザーストーリーごとに「必要な分だけ」作り、実装と同時にアップデートすることが多いです。

#### 含まれる情報
- 画面やAPIの具体的仕様（入力/出力、パラメータ、制約、エラー処理）
- テーブル定義やクラステンプレート（必要に応じて）
- UIモック、ワイヤーフレーム、Figma/AdobeXD等のデザイン資料
- 処理フローの詳細（複雑なアルゴリズムがある場合のみ図解するなど）

#### フォーマット
- コードと同じGitリポジトリでMarkdown管理
- 画面やAPI仕様はSwagger / OpenAPIで管理し、自動ドキュメント化
- コードコメントやペアプロ、単体テストが詳細設計の一部を兼ねることも

#### 完成条件（例: Definition of Done）
- 各機能の実装に必要な情報がそろい、チーム内で理解されている
- コードレビュー時に参照可能な形で、手戻りなく開発できる程度の仕様が共有されている
- 仕様が変更になった際、ドキュメントやテストが同期される運用が機能している
- 実装・テストで不明点や矛盾が出なければ、当該詳細設計は"現時点で完了"とみなす

**ポイント**: ウォーターフォールのように「全機能分まとめた詳細設計書が完成してから実装」ではなく、スプリント内でのユーザーストーリーに合わせ、必要な分だけ詳細設計 → 実装 → テスト → リファクタという流れが多いです。

## 3. まとめ：比較するとどう違うか？

### 観点別比較

| 観点 | ウォーターフォール型 | アジャイル型 |
|------|---------------------|-------------|
| ドキュメントの完成時期 | 各工程ごとに「文書の完成・承認」を経て次工程へ | 必要なタイミングで作成・更新し続ける（サインオフというより合意ベース） |
| 完成条件の考え方 | ある程度"大部"の文書を固め、ステークホルダー承認を受ける | 「Definition of Done/Ready」で必要最低限を満たせばOK。随時更新あり |
| 具体例（要件定義） | すべての機能要件・非機能要件を網羅したドキュメントを作成しサインオフ | バックログ（ユーザーストーリー）にまとめ、継続的に追加・変更する |
| 具体例（基本設計） | アーキテクチャ・外部I/F・DB構造を1つのドキュメントに集約し承認後固定化 | アーキテクチャを軽量ドキュメント（Wiki/Markdown）で共有し、必要に応じてADRなどで更新 |
| 具体例（詳細設計） | 画面項目や処理フローチャート、クラス設計などを一括で詳細化 | スプリントごと、機能単位で必要になった設計情報をその都度追加・更新 |

### 要点整理

#### ウォーターフォール型:
- 各ドキュメントが「完成」していないと次の工程へ進めない
- 完成条件は「すべての必要事項が網羅され、ステークホルダーの承認を得る」ことが基本
- 文書が大部化しやすく、変更コストが高い

#### アジャイル型:
- ドキュメントを「1回で完成」させるより、**"必要な情報が必要なタイミングでそろっている"**ことを重視
- 完成条件はDefinition of Doneや受け入れ基準に紐づき、小刻みにレビュー＆合意を得ながら進む
- 文書化は軽量に行い、コードやテストと同じリポジトリ内で管理・更新することが多い

### 最終的なポイント

- ウォーターフォール型: 各工程の文書に「完成基準」が明確にあり、大量の情報を網羅してステークホルダー承認を得るのが一般的
- アジャイル型: そもそもドキュメントを1回で"完成"させることを目指さない
  - ただし、**「Definition of Done (DoD)」や「Definition of Ready (DoR)」**などで「ここまで書かれていれば、このストーリーは実装可能・テスト可能」と判断するための基準を作る
  - これを満たした段階で「現時点ではドキュメントが完成した」とみなし、機能実装やテストを進める。後で要件変更があれば再度アップデートする

要するに、"完成"の線引きが厳格かつ一度きりか（ウォーターフォール）、または**都度必要な範囲で合意を取りながら進めるか（アジャイル）**という違いが、ドキュメントの完成条件に表れています。

## 4. クオリティと合意形成の関係

最終的に揃う情報の内容やクオリティそのものは、ウォーターフォール型でもアジャイル型でも大きな差はありません。違いは以下の2点に集約されます：

1. どの段階で文書をどれだけ作り込むか
2. "完成"とみなすための合意形成のプロセス（承認フロー）がどうなっているか

### ウォーターフォール型の特徴

#### 一括で合意し、後工程に進む
- 各工程の文書（要件定義書、基本設計書、詳細設計書など）をある程度作り込み、すべてのステークホルダーが承認したのちに次の工程へ進む
- 後からの変更は「要件定義書を修正 → 影響範囲を再設計 → 再承認」という形でコストが高くなりがち

#### 文書は分厚くなりがちだが、承認時点で"確定"した安心感
- オフショアや外注先が多い場合、明確な仕様合意があるため責任範囲が明確になる
- ただし、短期間で大きな仕様変更が入りにくい（もしくは入ると手戻りが大きい）

### アジャイル型の特徴

#### 小刻みに合意し、頻繁に更新する
- "完成"と呼ぶタイミングを細かく設定（Definition of Doneなど）し、バックログや設計情報を都度アップデート
- 変更が発生してもスプリントやイテレーション単位で素早く反映し、小さな衝撃にとどめる

#### 文書は軽量だが、常に最新版にアップデート
- コードリポジトリで文書を管理（Docs as Code など）
- 大量の承認プロセスより、継続的な合意形成（レビューやPull Request）を重視

### クオリティは最終的に同じでも、プロセスが違う

#### 共通点:
- 要件、アーキテクチャ、機能仕様など、最終的に必要となる情報は同じ
- 運用保守フェーズで参照する際は、どちらの手法でも同等の粒度の情報が必要

#### 相違点:
- 文書をいったん確定し、変更がある場合は改訂扱いにする（ウォーターフォール）
- 最初は必要最低限の情報で始めて、常に新しい知見や変更を取り込んでいく（アジャイル）
- 合意形成のタイミングや形式、承認フローが異なる
